# Modern-computer-networks.HomeTask3
## Запуск

Запускался проект в двух конфигурациях: 
1) оба клиента в одной сети 
2) оба за разными NAT

Ситуация, когда только один клиент за NAT, концептуально не сложнее ситуации 2.

- Локальный запуск (оба клиента в одной сети):

В терминале в папке задания ввести
```bash
docker-compose up
```
- Запуск в gns3:
    - копирование файлов с кодом на контейнеры
    - настройка сети
    - раздельный запуск сервера и клиентов

## NAT Hole Punching. Общая схема работы

### Шаг 1: Регистрация клиентов на сервере
- Оба клиента (Client A и Client B) подключаются к Rendezvous серверу
- Сервер видит **внешние адреса** клиентов (через NAT)
- Клиенты отправляют свои **локальные адреса** серверу

### Шаг 2: Обмен контактными данными
- Сервер отправляет каждому клиенту информацию о peer-е:
  - **Внешний адрес** peer-а (через NAT)
  - **Локальный адрес** peer-а (внутри его сети)
  - **Тип соединения** (local/one_nat/both_nat)

### Шаг 3: Процесс Hole Punching
1. **Одновременная отправка UDP-пакетов**:
   - Оба клиента начинают отправлять пакеты на внешний адрес peer-а
   - Пакеты проходят через NAT и "открывают" порты

2. **NAT создает временные правила**:
   - NAT запоминает исходящие соединения
   - Разрешает входящие пакеты с того же адреса и порта

3. **Установление прямого соединения**:
   - После успешного обмена пакетами клиенты могут общаться напрямую
   - Rendezvous сервер больше не участвует в обмене данными

Скрины примеров успешной работы смотри в ***example.ipynb***

## Наша сетевая топология

Rendezvous Server: 10.0.1.10:5000

NAT1:
- WAN: 10.0.1.1 (к Switch1)
- LAN: 192.168.1.1 (к PC1)

PC1:
- Локальный: 192.168.1.1:random_port
- Внешний (через NAT1): 10.0.1.1:mapped_port

NAT2:
- WAN: 10.0.1.2 (к Switch1)  
- LAN: 192.168.2.1 (к PC2)

PC2:
- Локальный: 192.168.2.1:random_port
- Внешний (через NAT2): 10.0.1.2:mapped_port

**NAT1 (10.0.1.1):**
- Порт: **39936**

**NAT2 (10.0.1.2):**
- Порт: **36479**

## Детальный процесс с реальными портами:

### Фаза 1: Регистрация на сервере

**PC1 -> Rendezvous Server:**
Локальный: 192.168.1.1:random_port1
Через NAT1: 10.0.1.1:39936 → 10.0.1.10:5000
Сервер видит: клиент с адресом 10.0.1.1:39936

**PC2 -> Rendezvous Server:**
Локальный: 192.168.2.1:random_port2  
Через NAT2: 10.0.1.2:36479 → 10.0.1.10:5000
Сервер видит: клиент с адресом 10.0.1.2:36479

### Фаза 2: Обмен контактными данными

**Сервер -> PC1:**
"Твой peer PC2 находится по адресу: 10.0.1.2:36479"

**Сервер -> PC2:**
"Твой peer PC1 находится по адресу: 10.0.1.1:39936"

### Фаза 3: Процесс Hole Punching

**PC1 начинает отправлять пакеты:**
PC1 -> NAT1: "HOLE_PUNCH_ATTEMPT" на 10.0.1.2:36479
NAT1 транслирует: 10.0.1.1:39936 → 10.0.1.2:36479


**Одновременно PC2 отправляет пакеты:**
PC2 -> NAT2: "HOLE_PUNCH_ATTEMPT" на 10.0.1.1:39936  
NAT2 транслирует: 10.0.1.2:36479 → 10.0.1.1:39936


### Фаза 4: Пробивание NAT

**NAT1 создает правило:**
"Разрешить входящие пакеты от 10.0.1.2:36479 на порт 39936"

**NAT2 создает правило:**
"Разрешить входящие пакеты от 10.0.1.1:39936 на порт 36479"

### Фаза 5: Установление прямого соединения

10.0.1.1:39936 -> 10.0.1.2:36479  (PC1 -> PC2)
10.0.1.2:36479 -> 10.0.1.1:39936 (PC2 -> PC1)

**После установления:**
PC1 (192.168.1.1) <-> NAT1 (10.0.1.1:39936) <-> NAT2 (10.0.1.2:36479) <-> PC2 (192.168.2.1)

### Итог:
- Клиенты могут общаться **напрямую** без сервера
- NAT запомнил правила для взаимной коммуникации

### Что видно в записи:
- **Пакеты идут в обе стороны** через NAT
- **UDP-пакеты** с пометкой "HOLE_PUNCH_ATTEMPT"
- **Ответные пакеты** "HOLE_PUNCH_RESPONSE"
- После установления соединения - обычный обмен данными