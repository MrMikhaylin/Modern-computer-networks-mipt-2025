# Реализация а-ля ACME сервера

ACME (Automated Certificate Management Environment) - сервер автоматического управления сертификатами открытых ключей. Протокол разработан [Let's Encrypt](https://letsencrypt.org). Информация про [ACME-клиенты](https://letsencrypt.org/ru/docs/client-options/).

Вам предстоит реализовать аналог Let's encrypt. Сервер который выступает в роли CA и подписывает пользовательские сертификаты. Для справки [как вообще работает Let's Encrypt](https://letsencrypt.org/ru/how-it-works/).

Общение с сервером должно происходить по HTTP. Реализовать http сервер можно на чем угодно.

Реализовывать проверку владения сервером и доменом не нужно. В вашем случае авторизация пользователя выполняется по паре ключей и "общеизвестной фразе": `d2caac68c555fa37e412171cd5240e2d0bb1bea23d4ccdb950157d37136ebcf46ed3263984d5ec5ffbb5cd4e7092b2c802b9d5a9c372c3492afa09eaf35fb9ac`. 

Реализация вашего сервера должна быть реализована в директории `/acme`. Так как реализация не зависит от языка, для удобства проверки следует поместить всю вашу реализацию в docker. Пример `Dockerfile` находится в `/acme`.

Ваш сервис выступает в роли CA. Как создать свой CA смотреть в семинаре про TLS. Желательно сделать цепочку ROOT -> CA. При этом сертификаты и ключи ROOT и CA можно выпустить один раз. Например, создаете нужные сертификаты и помещаете их в определенную директорию docker образа.

Для полноценной работы сервера необходима база данных выпущенных сертификатов. В тестах будет заложен перезапуск сервера, необходимо чтобы состояние восстановилось. Можно реализовать ее в файловой системе или подключить что то внешнее(SQLITE), на ваше усмотрение.

## Алгоритм авторизации
В http заголовок Authorization поместить ЭЦП "общеизвестной фразы" по закрытому ключу клиента, в Hex Encode. Сервер получив данный заголовок декодирует его открытым ключом. Формат заголовка Authorization:

`Authorization: HEX(SIGN(SHA1(Фраза), PRIVATE))`

Где:
 `HEX` - функция hex encode
 `SIGN` - подпись RSA
 `SHA1` - хеш сумма SHA1


## Методы для реализации

* `POST /sign` - подписать сертификат.
    * Входные данные:
        * Заголовок Authorization как описано выше
        * Заголовок x-Public-Key = `HEX(PUBLIC)`
        * Content-Type = `application/pkcs10`
        * В теле - CSR(Certificate Sign Request) вашего сертификата открытого ключа
    * Выходные данные:
        * 201 - Created
        * Подписанный сертификат в формате pem
    * Ошибки:
        * Если csr не валиден - `400`
        * При отсутствии заголовка `Authorization` должно возвращать - `401`
        * Если подпись фразы не соотносится с открытым ключом - `403`
        * Если для открытого ключа уже есть сертификат - `409`
* `GET /verify` - проверяет валиден ли сертификат.
    * Входные данные:
        * Заголовок x-Public-Key = `HEX(PUBLIC)`
    * Выходные данные:
        * 200 - OK
        * `TRUE` или `FALSE` в теле
    * Ошибки: 
        * Если нет заголовка x-Public-Key - `400`
        * Если для открытого ключа нет сертификата в базе - `404`

## Тестирование
Для тестов используется pytest. Все тесты описаны в файле `acme_test.py`.
